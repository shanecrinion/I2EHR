install.packages("shiny")
library(shiny)
knitr::opts_chunk$set(echo = TRUE)
renderPlot({
hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
xlab = "Duration (minutes)", main = "Geyser eruption duration")
dens <- density(faithful$eruptions, adjust = input$bw_adjust)
lines(dens, col = "blue")
})
inputPanel(
selectInput("n_breaks", label = "Number of bins:",
choices = c(10, 20, 35, 50), selected = 20),
sliderInput("bw_adjust", label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
)
renderPlot({
hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
xlab = "Duration (minutes)", main = "Geyser eruption duration")
dens <- density(faithful$eruptions, adjust = input$bw_adjust)
lines(dens, col = "blue")
})
rsconnect::setAccountInfo(name='shanecrinion', token='88FD128D9E9466ECCA6AEA7EB6374413', secret='SsXkB6ah7b6uhaa8Ei/CLzgihlnHf9sN/nU26wVw')
# run the application
shinyApp(ui = ui, server = server)
library(shiny)
# define the UI for application
ui <- fluidPage(
numericInput(inputId = "n", "Sample size", value = 25
)
)
# define server logic
server <- function(input,output) {
}
# run the application
shinyApp(ui = ui, server = server)
library(shiny)
# define the UI for application
ui <- fluidPage(
# input function
numericInput(inputId = "n", "Sample size", value = 25
),plotOutput("hist")
)
# define server logic
server <- function(input,output) {output$hist <- renderPlot({
hist(rnorm(input$n))
})
}
# run the application
shinyApp(ui = ui, server = server)
library(shiny)
# define the UI for application
ui <- fluidPage(
# input function
numericInput(inputId = "n", "Sample size", value = 25
),plotOutput("hist",width =30)
)
# define server logic
server <- function(input,output) {output$hist <- renderPlot({
hist(rnorm(input$n))
})
}
# run the application
shinyApp(ui = ui, server = server)
)
)
# define server logic
server <- function(input,output) {output$hist <- renderPlot({
hist(rnorm(input$n))
})
}
# run the application
shinyApp(ui = ui, server = server)
library(shiny)
# define the UI for application
ui <- fluidPage(
# input function
numericInput(inputId = "n", "Sample size", value = 25
),plotOutput("hist",width = 10, height = 10)
)
# define server logic
server <- function(input,output) {output$hist <- renderPlot({
hist(rnorm(input$n))
})
}
# run the application
shinyApp(ui = ui, server = server)
library(shiny)
# define the UI for application
ui <- fluidPage(
# input function
numericInput(inputId = "n", "Sample size", value = 2
),plotOutput("hist",width = 10, height = 10)
)
# define server logic
server <- function(input,output) {output$hist <- renderPlot({
hist(rnorm(input$n))
})
}
# run the application
shinyApp(ui = ui, server = server)
library(shiny)
# define the UI for application
ui <- fluidPage(
# input function
numericInput(inputId = "n", "Sample size", value = 2
),plotOutput("hist")
)
# define server logic
server <- function(input,output) {output$hist <- renderPlot({
hist(rnorm(input$n))
})
}
# run the application
shinyApp(ui = ui, server = server)
library(shiny)
example snippets
ui <- fluidPage(
textInput("a","","A")
)
server <-
function(input,output){
rv
<-
reactiveValues
()
rv$number <- 5
}
library(shiny)
ui <- fluidPage(
textInput("a","","A")
)
server <-
function(input,output){
rv<- reactiveValues()
rv$number <- 5
}
shinyApp(ui, server)
library(shiny)
ui <- fluidPage(
textInput("a","","A")
)
server <-
function(input,output){
rv<- reactiveValues()
rv$number <- 5
}
shinyApp(ui, server)
library(shiny)
library(shiny)
ui <- fluidPage(
textInput("a","","A"),
textOutput("b")
)
server <-
function(input,output){
output$b
<-
renderText({
input$a
})
}
shinyApp(ui, server)
shinyApp(ui, server)
knitr::opts_chunk$set(echo = TRUE)
nchar(rand) #fixed unicode string #rand means that it is the length of the variable made above called rand
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse="") #function it applies is to add ATGC to each component
nchar(rand) #fixed unicode string #rand means that it is the length of the variable made above called rand
nchar(rand) #fixed unicode string #rand means that it is the length of the variable made above called rand
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse="") #function it applies is to add ATGC to each component
summary(nchar(rand))
summary(nchar(rand))
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse="") #function it applies is to add ATGC to each component
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse="") #function it applies is to add ATGC to each component
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse="")
#function it applies is to add ATGC to each component
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse=""))
summary(nchar(rand))
summary(nchar(rand))
head(nchar)
head(rand)
summary(nchar(rand))
View(head(nchar))
View(nchar(rand))
rand[nchar(rand)== 10]
nchar(rand)
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse=""))
rand[nchar(rand)== 10]
hist(nchar(rand))
summary(nchar(rand)) #summary of the random values generated
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse=""))
print(rand)
hist(nchar(rand))
print(rand[1])
print(rand[1:10])
rand.sub[1:10]
rand.sub[1:10]
rand.sub <- substr(rand, 1,3) #subset to only first 3 letters
print(rand[1:10])
rand.sub[1:10]
sort(table(substr(rand, 1, 3)))
library(Biostrings)
library(Biostrings)
install.packages('Biostrings')
library(Biostrings)
install.packages('Biostrings')
library(Biostrings)
install.packages(Biostrings)
install.packages('Biostrings')
library(Bioconductor)
install.packages('Bioconductor')
setRepositories()
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
#sapply preserves the dimensions and dimension names
rand <- sapply(1:100, function(x) paste(sample(c("A","T","G","C"), sample(10:20), replace=T), collapse="")) #creates a string of sequences
#sequences between 10 and 20 in length
#function it applies is to add ATGC to each component
nchar(rand) #takes the character vector and returns the vector of elements with the size of the previous elements
summary(nchar(rand)) #summary of the random values generated - indicates the minimum and maximum size for each
hist(nchar(rand)) #indicates the most common frequency for each
rand[nchar(rand)== 10] #selects all the values that are 10 in length
rand[grep("AAAA", rand)] #grabs all occurances of AAAA in each sequence
gsub("AAA", "NNN", rand) #replaces each occurance of AAA with NNN
rand.sub <- substr(rand, 1,3) #subset to only first 3 letters
print(rand[1:10])
rand.sub[1:10] #confirm that limited to only the first 3 symbols
sort(table(substr(rand, 1, 3))) #sort as a table all codons
install.packages("BiocManager")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Biostrings", version = "3.8")
install.packages('BiocManager')
library()
source("http://bioconductor.org/biocLite.R")
biocLite()
7
biocLite('Biostrings')
rand2 <- sapply(1:1000, function(x) paste(sample(c("A","T","G","C"), sample(5:100), replace=T), collapse=""))
myseq
myseq <- DNAStringSet(rand2)
library(Biostrings)
library(Biostrings)
rand2 <- sapply(1:1000, function(x) paste(sample(c("A","T","G","C"), sample(5:100), replace=T), collapse=""))
myseq <- DNAStringSet(rand2)
myseq
as.character(myseq[width(myseq)<10])
summary(width(myseq))
hist(width(myseq))
myseq[width(myseq)<10]
as.character(myseq[width(myseq)<10])
mysubseq <- DNAStringSet(myseq[1:3], start=c(1,2,3), end=c(4,8,5))
af <- alphabetFrequency(myseq, baseOnly=TRUE)
dim(af)
print(dim(af)) #1000 sequences each with
head(af)#
myseq[af[,1] ==0,]
head(af)#indicates the number of each nucleotide
myseq[af[,1] ==0,]
head(af)#indicates the number of each nucleotide
myseq[af[,1] ==0,] #
af <- alphabetFrequency(myseq, baseOnly=TRUE) #contains the row frequency
dim(af) #1000 sequences each with
head(af)#indicates the number of each nucleotide
myseq[af[,1] ==0,] #
boxplot(af)
boxplot(dinucleotideFrequency(myseq),las=2)
af2 <- alphabetFrequency(myseq, baseOnly=TRUE) / width(myseq)
boxplot(af2)
myseq[gcCounts > 0.75]
gcCounts <- af2[,"C"] + af2[,"G"]
summary(gcCounts)
myseq[gcCounts > 0.75]
reverseComplement(myseq)
reverse(myseq)
reverseComplement(myseq)
RNAString(myseq[[1]])
translate(myseq)
writeXStringSet(myseq, file="myseqs.fa")
writeXStringSet(myseq, file="myseqs.fa")
getwd()
seq_names<-"Seq1"
seq_names<-"Seq1"
for(i in 2:1000){
seq_names<-c(seq_names, paste("Seq", i, sep=""))
}
names(myseq)<-seq_names
writeXStringSet(myseq, file="myseqs.fa"
writeXStringSet(myseq, file="myseqs.fa")
seq_names<-"Seq1"
for(i in 2:1000){
seq_names<-c(seq_names, paste("Seq", i, sep=""))
}
names(myseq)<-seq_names
writeXStringSet(myseq, file="myseqs.fa")
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
table(width(fq))
sread(fq)
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
seq_names<-"Seq1"
for(i in 2:1000){
seq_names<-c(seq_names, paste("Seq", i, sep=""))
}
names(myseq)<-seq_names
writeXStringSet(myseq, file="myseqs.fa")
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
readLines(myfile,n=12)
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
getwd()
readLines(myfile,n=12)
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
seq_names<-"Seq1"
for(i in 2:1000){
seq_names<-c(seq_names, paste("Seq", i, sep=""))
}
names(myseq)<-seq_names
writeXStringSet(myseq, file="myseqs.fa")
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
biocLite('ShortRead')
library(ShortRead)
fq <- readFastq(myfile)
fq <- readFastq(myfile)
library(ShortRead)
library(ShortRead)
fq <- readFastq(myfile)
biocLite('ShortRead')
biocLite('ShortRead')
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
readLines(myfile,n=12)
table(width(fq))
sread(fq)
fq <- readFastq(myfile)
biocLite('ShortRead')
myfile <- "VEC_F_1_GTGAAA_L004_R1_003.fastq"
library(ShortRead)
library(ShortRead)
fq <- readFastq(myfile)
id(fq)
sread(fq)
myfile <- "test.fastq"
readLines(myfile,n=12)
library(ShortRead)
fq <- readFastq(myfile)
fq
sread(fq)
quality(fq)
id(fq)
table(width(fq))
abc <- alphabetByCycle(sread(fq))
dim(abc)
plot(abc[1,],type="n",ylim=range(0,max(abc)))
text(abc[1,],labels="A",col="red")
text(abc[2,],labels="C",col="orange")
text(abc[3,],labels="G",col="green")
text(abc[4,],labels="T",col="blue")
tbl <- tables(fq)
names(tbl)
tbl$top[1:5]
tbl$distribution
sum(srduplicated(fq))
# Identifies duplicated reads
no_dups<-fq[!srduplicated(fq)
# Identifies duplicated reads
no_dups<-fq[!srduplicated(fq)
qual <- as(quality(fq), "matrix")
qual <- as(quality(fq), "matrix")
qual <- as(quality(fq), "matrix")
dim(qual)
plot(colMeans(qual), type="b", ylim=c(20,40))
abline(h=37, col="red", lty=2
abline(h=37, col="red", lty=2)
qual <- as(quality(fq), "matrix")
dim(qual)
plot(colMeans(qual), type="b", ylim=c(20,40))
abline(h=37, col="red", lty=2)
filter1 <- nFilter(threshold=1)
# Keeps only reads without Ns
filter2 <- polynFilter(threshold=20, nuc=c("A","T","G","C"))
# Removes reads with >=20 of one nucleotide
filter <- compose(filter1, filter2)
fq[filter(fq)
filter1 <- nFilter(threshold=1)
# Keeps only reads without Ns
filter2 <- polynFilter(threshold=20, nuc=c("A","T","G","C"))
# Removes reads with >=20 of one nucleotide
filter <- compose(filter1, filter2)
fq[filter(fq)]
writeXStringSet(trimmed.seq, file="trimmed.fq", format="fastq",qualities=quals)
filter1 <- nFilter(threshold=1)
# Keeps only reads without Ns
filter2 <- polynFilter(threshold=20, nuc=c("A","T","G","C"))
# Removes reads with >=20 of one nucleotide
filter <- compose(filter1, filter2)
trimmed.seq <- fq[filter(fq)]
writeXStringSet(trimmed.seq, file="trimmed.fq", format="fastq",qualities=quals)
writeXStringSet(fq[filter(fq)], file="trimmed.fq", format="fastq",qualities=quals)
filter1 <- nFilter(threshold=1)
# Keeps only reads without Ns
filter2 <- polynFilter(threshold=20, nuc=c("A","T","G","C"))
# Removes reads with >=20 of one nucleotide
filter <- compose(filter1, filter2)
fq[filter(fq)]
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics("FHIR1.png")
knitr::include_graphics("FHIR2.png")
library(shiny); runApp('Documents/RShiny/ProjectDrafts/Datatable-of-Synthea-data.R')
install.packages("DT")
runApp('Documents/RShiny/ProjectDrafts/Datatable-of-Synthea-data.R')
install.packages("DT")
runApp('Documents/RShiny/ProjectDrafts/Database-add-condition-tab.R')
#import the synthea information that i want to make a datatable from
dir()
setwd('/home/shane/Documents/RShiny/csv/')
patients <- read.csv('patients.csv')
allergies <- read.csv('allergies.csv')
allergies <- read.csv('allergies.csv')
careplans <- read.csv('careplans.csv')
claims <- read.csv('claims.csv')
conditions <- read.csv('conditions.csv')
encounters <- read.csv('encounters.csv')
immunization <- read.csv('immunizations.csv')
medications <- read.csv('medications.csv')
observations <- read.csv('observations.csv')
procedures <- read.csv('procedures.csv')
alldata0 <- merge.data.frame(allergies, careplans, all.x=TRUE, all.y = TRUE)
alldata1 <-merge.data.frame(alldata0, claims, all.x=TRUE, all.y = TRUE)
alldata2 <-merge.data.frame(alldata1, conditions, all.x=TRUE, all.y = TRUE)
alldata3 <-merge.data.frame(alldata2, encounters, all.x=TRUE, all.y = TRUE)
alldata4 <-merge.data.frame(alldata3, immunization, all.x=TRUE, all.y = TRUE)
alldata5 <-merge.data.frame(alldata4, medications, all.x=TRUE, all.y = TRUE)
alldata6 <-merge.data.frame(alldata5, observations, all.x=TRUE, all.y = TRUE)
alldata7 <-merge.data.frame(alldata6, patients, all.x=TRUE, all.y = TRUE)
alldata8 <-merge.data.frame(alldata7, procedures, all.x=TRUE, all.y = TRUE)
merged_patient_data <- alldata8
runApp('~/Documents/RShiny/ProjectDrafts/Database-add-condition-tab.R')
runApp('~/Documents/RShiny/ProjectDrafts/WORKING-table-size-selection-sex-selection.R')
runApp('~/Documents/RShiny/beginnings-of-graphing-NR.R')
install.packages("DT")
runApp('~/Documents/RShiny/beginnings-of-graphing-NR.R')
runApp('~/Documents/RShiny/beginnings-of-graphing-NR.R')
knitr::include_graphics("Scalable1.png")
knitr::include_graphics("DeepPhenotyping.png")
knitr::include_graphics("Cardiovascular.png")
knitr::include_graphics("Cardiovascular.png")
```{r jc, echo=FALSE, fig.cap="", out.width = '100%'}
knitr::include_graphics("Cardiovascular.png")
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
runApp('~/Documents/GenomicDataAnalysis/Assignment 3 on Friday1443.R')
